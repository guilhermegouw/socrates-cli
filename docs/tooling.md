# Socrates CLI - Tooling Reference

This document describes each tool and component in the project's development infrastructure.

---

## Table of Contents

1. [Go Modules](#go-modules)
2. [Cobra CLI Framework](#cobra-cli-framework)
3. [golangci-lint](#golangci-lint)
4. [GitHub Actions CI](#github-actions-ci)
5. [Taskfile](#taskfile)

---

## Go Modules

**File:** `go.mod`, `go.sum`

### What It Does

Go modules is Go's dependency management system. It tracks which external packages your project uses and locks their versions for reproducible builds.

### Why Use It

- **Reproducibility:** Every developer and CI system gets the exact same dependency versions.
- **No GOPATH required:** Projects can live anywhere on your filesystem.
- **Semantic versioning:** Dependencies follow semver, making upgrades predictable.
- **Checksum verification:** `go.sum` contains cryptographic hashes to detect tampering.

### How It Works

```
module github.com/guilhermegouw/socrates-cli  # Module path (import path)

go 1.23.0                                      # Minimum Go version

require github.com/spf13/cobra v1.10.2         # Direct dependency

require (
    github.com/inconshreveable/mousetrap v1.1.0 // indirect  # Transitive deps
    github.com/spf13/pflag v1.0.9 // indirect
)
```

**Key commands:**
| Command | Purpose |
|---------|---------|
| `go mod init <path>` | Create a new module |
| `go mod tidy` | Add missing / remove unused dependencies |
| `go mod download` | Download dependencies to local cache |
| `go get <pkg>@<version>` | Add or update a dependency |

---

## Cobra CLI Framework

**Files:** `cmd/root.go`, `cmd/version.go`

### What It Does

Cobra is a library for creating CLI applications. It handles command parsing, flags, help text generation, and shell completions.

### Why Use It

- **Industry standard:** Used by Kubernetes, Hugo, GitHub CLI, and thousands of other projects.
- **Subcommand support:** Natural `socrates <command>` structure.
- **Auto-generated help:** `--help` flags work out of the box.
- **Shell completions:** Bash, Zsh, Fish, PowerShell support built-in.
- **Flag handling:** Both persistent (global) and local flags.

### How It Works

```go
func newRootCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "socrates",           // How users invoke it
        Short: "Brief description",  // Shown in parent's help
        Long:  "Detailed help...",   // Shown in own --help
        Run: func(cmd *cobra.Command, args []string) {
            // Command logic here
        },
    }

    // Add subcommands
    cmd.AddCommand(newVersionCmd())

    // Add flags
    cmd.Flags().StringP("config", "c", "", "config file path")

    return cmd
}
```

**Command structure:**
```
socrates                    # Root command
├── version                 # Subcommand
├── completion              # Auto-generated by Cobra
│   ├── bash
│   ├── zsh
│   ├── fish
│   └── powershell
└── help                    # Auto-generated by Cobra
```

**Version injection via ldflags:**
```bash
go build -ldflags "-X github.com/guilhermegouw/socrates-cli/cmd.Version=1.0.0"
```

This sets the `Version` variable at compile time without modifying source code.

---

## golangci-lint

**File:** `.golangci.yml`

### What It Does

golangci-lint is a fast, parallel linter runner that aggregates 50+ Go linters into a single tool. It catches bugs, enforces style, and identifies security issues.

### Why Use It

- **Speed:** Runs linters in parallel, shares AST parsing across linters.
- **Consistency:** Single config file, same results locally and in CI.
- **Comprehensive:** One tool instead of running 20+ separate linters.
- **Configurable:** Enable/disable linters, tune settings, exclude paths.

### How It Works

The `.golangci.yml` config has these sections:

```yaml
version: "2"              # Config format version

run:
  timeout: 5m             # Max time before giving up
  modules-download-mode: readonly  # Don't modify go.sum

linters:
  default: none           # Don't use default set
  enable:
    - errcheck            # List of linters to enable
    - govet
    # ...

  settings:               # Per-linter configuration
    gocyclo:
      min-complexity: 15

exclusions:               # Paths/patterns to skip
  rules:
    - path: "_test\\.go$"
      linters:
        - errcheck        # Don't check errors in tests

formatters:               # Code formatters (v2 feature)
  enable:
    - gofmt
    - goimports
```

### Enabled Linters Explained

| Linter | What It Catches |
|--------|-----------------|
| **errcheck** | Unchecked error returns: `f.Close()` instead of `_ = f.Close()` |
| **govet** | Suspicious constructs: `fmt.Printf("%d", str)` type mismatches |
| **ineffassign** | Useless assignments: `x := 5; x = 10` (first assignment unused) |
| **staticcheck** | Bugs, simplifications, performance: deprecated functions, nil checks |
| **unused** | Dead code: functions/variables never used |
| **bodyclose** | HTTP response bodies not closed (causes resource leaks) |
| **copyloopvar** | Loop variable captured by closure (Go < 1.22 bug pattern) |
| **dupl** | Copy-pasted code blocks (DRY violations) |
| **errname** | Error vars should be `ErrFoo`, error types `FooError` |
| **errorlint** | Wrong error wrapping: `err == ErrFoo` vs `errors.Is(err, ErrFoo)` |
| **exhaustive** | Non-exhaustive switch on enum types |
| **gochecknoinits** | `init()` functions (often cause hidden side effects) |
| **goconst** | Magic strings that should be constants |
| **gocritic** | Opinionated style: `if err != nil { return err }; return nil` → `return err` |
| **gocyclo** | High cyclomatic complexity (too many branches) |
| **godot** | Comments should end with a period |
| **gosec** | Security issues: SQL injection, weak crypto, hardcoded creds |
| **misspell** | Typos in comments and strings |
| **nakedret** | Naked returns in long functions (hard to read) |
| **nilerr** | Returning nil when error is not nil |
| **noctx** | HTTP requests without context (can't be cancelled) |
| **prealloc** | Slice could be pre-allocated: `make([]T, 0, knownSize)` |
| **predeclared** | Shadowing builtins: `var len int` shadows `len()` |
| **revive** | Successor to golint: exported names, error strings, etc. |
| **tparallel** | Missing `t.Parallel()` in test functions |
| **unconvert** | Unnecessary type conversions: `int(x)` when x is already int |
| **unparam** | Unused function parameters |
| **whitespace** | Unnecessary blank lines at start/end of blocks |

### Running Locally

```bash
# Run all linters
golangci-lint run

# Run and auto-fix what's possible
golangci-lint run --fix

# Run specific linters only
golangci-lint run --enable=gosec,errcheck

# Show what would be run
golangci-lint linters
```

---

## GitHub Actions CI

**File:** `.github/workflows/ci.yml`

### What It Does

GitHub Actions is a CI/CD platform that runs automated workflows on every push and pull request. Our workflow runs linting, testing, building, and security scanning.

### Why Use It

- **Native integration:** Built into GitHub, no external service needed.
- **Free for public repos:** Unlimited minutes for open source.
- **Matrix builds:** Test on multiple OS/Go versions in parallel.
- **Caching:** Speed up builds by caching Go modules.

### How It Works

```yaml
name: CI

on:
  push:
    branches: [main]      # Run on pushes to main
  pull_request:
    branches: [main]      # Run on PRs targeting main

permissions:
  contents: read          # Minimal permissions (security)

jobs:
  lint:                   # Job name
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4           # Get code
      - uses: actions/setup-go@v5           # Install Go
        with:
          go-version: "1.23"
          cache: true                       # Cache go modules
      - uses: golangci/golangci-lint-action@v6  # Run linter
```

### Our CI Pipeline

```
┌─────────────────────────────────────────────────────┐
│                    Push / PR                         │
└─────────────────────────────────────────────────────┘
                         │
         ┌───────────────┼───────────────┐
         ▼               ▼               ▼
    ┌─────────┐    ┌─────────┐    ┌─────────────┐
    │  Lint   │    │  Test   │    │   Build     │
    │         │    │         │    │             │
    │golangci │    │go test  │    │ go build    │
    │ -lint   │    │ -race   │    │             │
    └─────────┘    │coverage │    └─────────────┘
                   └─────────┘
                        │
                   ┌─────────┐
                   │Security │
                   │         │
                   │govuln-  │
                   │ check   │
                   └─────────┘
```

| Job | What It Does | Why |
|-----|--------------|-----|
| **lint** | Runs golangci-lint | Catch style/bug issues before review |
| **test** | `go test -race -coverprofile` | Find bugs, race conditions, track coverage |
| **build** | `go build ./...` | Ensure code compiles |
| **security** | `govulncheck ./...` | Find known vulnerabilities in dependencies |

### Coverage Reporting

Tests upload coverage to Codecov, which:
- Tracks coverage percentage over time
- Comments on PRs with coverage diff
- Fails PRs that decrease coverage (optional)

Requires adding `CODECOV_TOKEN` secret in repo settings.

---

## Taskfile

**File:** `Taskfile.yaml`

### What It Does

Task is a task runner / build tool. It's like Make but with a simpler YAML syntax, better cross-platform support, and modern features.

### Why Use It

- **Simpler than Make:** No tabs-vs-spaces issues, clearer syntax.
- **Cross-platform:** Works the same on Linux, macOS, Windows.
- **Dependencies:** Tasks can depend on other tasks.
- **Variables:** Dynamic values from shell commands or environment.
- **Parallel execution:** Run independent tasks concurrently.

### How It Works

```yaml
version: "3"

vars:
  BINARY_NAME: socrates
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  LDFLAGS: >-
    -X github.com/guilhermegouw/socrates-cli/cmd.Version={{.VERSION}}

tasks:
  build:
    desc: Build the binary
    cmds:
      - go build -ldflags "{{.LDFLAGS}}" -o {{.BINARY_NAME}} .

  test:
    desc: Run tests
    cmds:
      - go test -v -race ./...

  check:
    desc: Run all checks
    cmds:
      - task: fmt      # Run fmt first
      - task: lint     # Then lint
      - task: test     # Then test
```

### Available Tasks

| Task | Command | Description |
|------|---------|-------------|
| `task` | (default) | List all available tasks |
| `task build` | `go build -ldflags...` | Build binary with version info |
| `task run` | `go run .` | Run without building |
| `task install` | `go install` | Install to `$GOPATH/bin` |
| `task fmt` | `gofmt -w -s .` | Format all code |
| `task lint` | `golangci-lint run` | Run linters |
| `task lint:fix` | `golangci-lint run --fix` | Lint and auto-fix |
| `task vet` | `go vet ./...` | Run go vet |
| `task test` | `go test -race ./...` | Run tests with race detection |
| `task test:coverage` | `go test -coverprofile...` | Tests + HTML coverage report |
| `task test:short` | `go test -short ./...` | Skip slow tests |
| `task security` | `govulncheck ./...` | Check for vulnerabilities |
| `task deps` | `go mod tidy` | Clean up dependencies |
| `task deps:update` | `go get -u ./...` | Update all dependencies |
| `task clean` | `rm -f socrates` | Remove build artifacts |
| `task check` | fmt + lint + vet + test | All quality checks |
| `task ci` | lint + test + build + security | Same as GitHub Actions |

### Variable Interpolation

```yaml
vars:
  VERSION:
    sh: git describe --tags  # Run shell command, capture output

tasks:
  build:
    cmds:
      - echo "Building {{.VERSION}}"  # Use variable
```

### Task Dependencies

```yaml
tasks:
  check:
    cmds:
      - task: fmt    # Runs fmt task first
      - task: lint   # Then lint
      - task: test   # Then test
```

---

## Summary

| Component | File(s) | Purpose |
|-----------|---------|---------|
| Go Modules | `go.mod`, `go.sum` | Dependency management |
| Cobra | `cmd/*.go` | CLI framework |
| golangci-lint | `.golangci.yml` | Code quality (27 linters) |
| GitHub Actions | `.github/workflows/ci.yml` | CI/CD pipeline |
| Taskfile | `Taskfile.yaml` | Local development tasks |

This tooling setup ensures:
1. **Consistent code style** across all contributors
2. **Early bug detection** before code reaches production
3. **Security scanning** for vulnerable dependencies
4. **Reproducible builds** with locked dependencies
5. **Fast local development** with simple task commands
